<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Jet Game — Joystick + Speed + Missiles (Touch)</title>
  <style>
    :root { --bg:#0b1220; --panel:rgba(255,255,255,0.05); --accent:#1fb6ff; --ui-size:110px; }
    html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,#031225,#061428);color:#dfefff;-webkit-user-select:none;user-select:none;touch-action:none;}
    #hud{position:absolute;z-index:20;left:12px;top:12px;padding:10px;background:var(--panel);border-radius:8px;backdrop-filter:blur(6px);max-width:420px}
    #title{font-weight:700;font-size:18px;color:var(--accent);margin-bottom:6px}
    #controls{margin-bottom:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    #status{font-size:14px;display:flex;gap:12px;margin-bottom:6px}
    #instructions{font-size:13px;opacity:0.95}
    canvas{display:block;width:100vw;height:100vh;background:transparent}
    button, input[type="range"]{vertical-align:middle}
    /* Touch UI */
    .touch-ui { position: fixed; bottom: 18px; z-index: 30; }
    #joyBase {
      left: 18px;
      width: var(--ui-size);
      height: var(--ui-size);
      background: rgba(255,255,255,0.04);
      border-radius: 50%;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.02);
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
    }
    #joyKnob {
      width: calc(var(--ui-size) * 0.48);
      height: calc(var(--ui-size) * 0.48);
      background: rgba(31,182,255,0.95);
      border-radius: 50%;
      transform: translate(0,0);
      transition: transform 0.04s linear;
      box-shadow: 0 4px 10px rgba(0,0,0,0.45);
    }
    #fireBtn {
      right: 18px;
      width: var(--ui-size);
      height: var(--ui-size);
      background: linear-gradient(180deg,#ff5f6d,#ff9966);
      border-radius: 50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#112;
      border: 3px solid rgba(255,255,255,0.08);
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      position: absolute;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    #fireBtn:active { transform: scale(0.98); }
    .touch-label { font-size: 14px; color: rgba(255,255,255,0.9); }
    /* Hide touch UI on large desktop if desired (but leaving for mouse support) */
    @media (min-width:900px){
      :root{--ui-size:120px;}
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="title">Jet Game</div>
    <div id="controls">
      <label>Max Speed: <input id="speedSlider" type="range" min="50" max="600" value="300" /></label>
      <span id="speedValue">300</span> px/s
      <button id="restartBtn">Restart</button>
    </div>
    <div id="status">
      <span id="score">Score: 0</span>
      <span id="missiles">Missiles: ∞</span>
      <span id="gpstatus">Gamepad: none</span>
    </div>
    <div id="instructions">
      Controls:
      <ul>
        <li>Touch: Left joystick = steer/throttle (drag up to accelerate), Right button = fire</li>
        <li>Gamepad: Left stick rotate, Right stick throttle (or left Y), Button A/0 to fire</li>
        <li>Keyboard: Arrow keys rotate, W/S throttle, Space to fire</li>
      </ul>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- Touch UI elements -->
  <div id="joyBase" class="touch-ui" aria-hidden="true">
    <div id="joyKnob"></div>
  </div>
  <div id="fireBtn" class="touch-ui" aria-hidden="true"><div class="touch-label">FIRE</div></div>

  <script>
  // Full game with added touch joystick + fire button
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(320, window.innerWidth);
      const h = Math.max(240, window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // position touch UI elements (they are fixed but size may change with CSS vars)
      positionTouchUI();
    }
    addEventListener('resize', resize);
    resize();

    // UI elements
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const scoreEl = document.getElementById('score');
    const gpstatus = document.getElementById('gpstatus');
    const restartBtn = document.getElementById('restartBtn');

    let maxSpeed = Number(speedSlider.value);
    speedValue.textContent = maxSpeed;
    speedSlider.addEventListener('input', e => { maxSpeed = Number(e.target.value); speedValue.textContent = maxSpeed; });
    restartBtn.addEventListener('click', initGame);

    const TAU = Math.PI*2;
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function posMod(n,m){return ((n % m) + m) % m;}

    // Input: keyboard & gamepad
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    let gamepadIndex = null;
    window.addEventListener('gamepadconnected', e => { gamepadIndex = e.gamepad.index; gpstatus.textContent = 'Gamepad: ' + e.gamepad.id; });
    window.addEventListener('gamepaddisconnected', e => { if (gamepadIndex === e.gamepad.index) gamepadIndex = null; gpstatus.textContent = 'Gamepad: none'; });

    setInterval(()=> {
      if (gamepadIndex === null && navigator.getGamepads) {
        const gps = navigator.getGamepads();
        for (let i=0;i<gps.length;i++){ if (gps[i]){ gamepadIndex = i; gpstatus.textContent = 'Gamepad: ' + gps[i].id; break; } }
      }
    }, 1500);

    // Touch joystick state
    const joyBase = document.getElementById('joyBase');
    const joyKnob = document.getElementById('joyKnob');
    const fireBtn = document.getElementById('fireBtn');

    const touchState = {
      joystick: { active:false, id:null, x:0, y:0 }, // x,y in -1..1
      fire: false
    };

    // Position the touch UI elements (they use fixed positioning via left/right CSS)
    function positionTouchUI(){
      // Ensure bottom offset (already via CSS). Nothing special required, but keep for future.
    }

    // Helper to get element center and radius
    function getBaseParams(el){
      const rect = el.getBoundingClientRect();
      return {
        cx: rect.left + rect.width/2,
        cy: rect.top + rect.height/2,
        r: Math.min(rect.width, rect.height)/2
      };
    }

    // Joystick pointer handling
    joyBase.addEventListener('pointerdown', (ev)=>{
      joyBase.setPointerCapture(ev.pointerId);
      const p = getBaseParams(joyBase);
      touchState.joystick.active = true;
      touchState.joystick.id = ev.pointerId;
      updateJoystickFromPointer(ev.clientX, ev.clientY, p);
    });
    joyBase.addEventListener('pointermove', (ev)=>{
      if (!touchState.joystick.active || touchState.joystick.id !== ev.pointerId) return;
      const p = getBaseParams(joyBase);
      updateJoystickFromPointer(ev.clientX, ev.clientY, p);
    });
    function endJoy(ev){
      if (!touchState.joystick.active || touchState.joystick.id !== ev.pointerId) return;
      touchState.joystick.active = false;
      touchState.joystick.id = null;
      touchState.joystick.x = 0; touchState.joystick.y = 0;
      // reset knob visual
      joyKnob.style.transform = 'translate(0px,0px)';
    }
    joyBase.addEventListener('pointerup', endJoy);
    joyBase.addEventListener('pointercancel', endJoy);
    joyBase.addEventListener('lostpointercapture', endJoy);

    function updateJoystickFromPointer(px, py, baseParams){
      const dx = px - baseParams.cx;
      const dy = py - baseParams.cy;
      const nx = dx / baseParams.r; // -inf..inf
      const ny = dy / baseParams.r;
      // clamp to [-1,1]
      const fx = clamp(nx, -1, 1);
      const fy = clamp(ny, -1, 1);
      // store normalized where up is negative Y -> throttle should be -fy
      touchState.joystick.x = fx; // steering
      touchState.joystick.y = fy; // invert when mapping to throttle
      // move knob visually (limit to radius*0.5)
      const pxMove = fx * baseParams.r * 0.5;
      const pyMove = fy * baseParams.r * 0.5;
      joyKnob.style.transform = `translate(${pxMove}px, ${pyMove}px)`;
    }

    // Fire button pointer handling
    fireBtn.addEventListener('pointerdown', (ev)=>{
      fireBtn.setPointerCapture(ev.pointerId);
      touchState.fire = true;
    });
    function endFire(ev){
      fireBtn.releasePointerCapture && fireBtn.releasePointerCapture(ev.pointerId);
      touchState.fire = false;
    }
    fireBtn.addEventListener('pointerup', endFire);
    fireBtn.addEventListener('pointercancel', endFire);
    fireBtn.addEventListener('lostpointercapture', endFire);

    // Game objects
    let jet, missiles, targets, lastTime, score, spawnTimer;

    function initGame(){
      const dpr = window.devicePixelRatio || 1;
      jet = { x: canvas.width/(2*dpr), y: canvas.height/(2*dpr), angle:-Math.PI/2, vx:0, vy:0, radius:16, acc:600, turnSpeed:4.0, cooldown:0 };
      missiles = []; targets = []; lastTime = performance.now(); score = 0; spawnTimer = 0;
    }

    function spawnTarget(){
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      const edge = Math.floor(Math.random()*4);
      let x, y;
      if (edge===0){ x=-30; y=Math.random()*h; }
      else if (edge===1){ x=w+30; y=Math.random()*h; }
      else if (edge===2){ x=Math.random()*w; y=-30; }
      else { x=Math.random()*w; y=h+30; }
      const angle = Math.atan2(h/2 - y, w/2 - x);
      const speed = 40 + Math.random()*120;
      targets.push({ x,y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, r:14+Math.random()*10, hp:1 });
    }

    function update(dt){
      if (!jet) return;

      // Input reading
      let gp = null;
      if (gamepadIndex !== null && navigator.getGamepads) {
        gp = navigator.getGamepads()[gamepadIndex] || null;
      }

      let throttle = 0; // -1..1
      let turnInput = 0; // -1..1
      let firePressed = false;

      // Keyboard fallback
      if (keys['ArrowLeft'] || keys['KeyA']) turnInput -= 1;
      if (keys['ArrowRight'] || keys['KeyD']) turnInput += 1;
      if (keys['KeyW']) throttle += 1;
      if (keys['KeyS']) throttle -= 1;
      if (keys['Space']) firePressed = true;

      // Gamepad mapping
      if (gp){
        const deadzone = 0.15;
        const ax = gp.axes[0]||0, ay = gp.axes[1]||0, ry = gp.axes[3]||0;
        if (Math.abs(ax) > deadzone) turnInput = ax;
        let throttleAxis = 0;
        if (Math.abs(ry) > deadzone) throttleAxis = -ry;
        else if (Math.abs(ay) > deadzone) throttleAxis = -ay;
        else throttleAxis = throttle;
        throttle = throttleAxis;
        if (gp.buttons && gp.buttons[0] && gp.buttons[0].pressed) firePressed = true;
        gpstatus.textContent = 'Gamepad: ' + gp.id;
      }

      // Touch joystick overrides keyboard/gamepad controls when active
      if (touchState.joystick.active){
        // Mapping: joystick X -> turn (-1 left .. 1 right)
        //           joystick Y (up negative) -> throttle (forward positive)
        // invert y so pushing up gives positive throttle
        turnInput = touchState.joystick.x;
        throttle = -touchState.joystick.y;
      }

      // touch fire button OR keyboard/gamepad fire
      if (touchState.fire) firePressed = true;

      // Speed control and physics
      const targetSpeed = throttle * maxSpeed;
      const forwardAx = Math.cos(jet.angle), forwardAy = Math.sin(jet.angle);
      const currentAlong = jet.vx * forwardAx + jet.vy * forwardAy;
      const speedError = targetSpeed - currentAlong;
      const accel = clamp(speedError * 4, -jet.acc, jet.acc);
      jet.vx += forwardAx * accel * dt;
      jet.vy += forwardAy * accel * dt;

      // Turning (scale a bit for nicer feel)
      jet.angle += turnInput * jet.turnSpeed * dt;

      // Drag
      jet.vx *= 0.995; jet.vy *= 0.995;

      // Cap
      const spd = Math.hypot(jet.vx, jet.vy);
      if (spd > maxSpeed * 1.5) {
        const s = (maxSpeed * 1.5) / spd;
        jet.vx *= s; jet.vy *= s;
      }

      // Move
      jet.x += jet.vx * dt; jet.y += jet.vy * dt;

      // Wrap
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      if (jet.x < -40) jet.x = w + 40;
      if (jet.x > w + 40) jet.x = -40;
      if (jet.y < -40) jet.y = h + 40;
      if (jet.y > h + 40) jet.y = -40;

      // Fire
      jet.cooldown -= dt;
      if (firePressed && jet.cooldown <= 0) { fireMissile(); jet.cooldown = 0.25; }

      // Missiles update
      for (let i = missiles.length - 1; i >= 0; i--) {
        const m = missiles[i];
        m.x += m.vx * dt; m.y += m.vy * dt; m.life -= dt;
        if (m.life <= 0 || m.x < -50 || m.x > w+50 || m.y < -50 || m.y > h+50) missiles.splice(i,1);
      }

      // Targets update & collisions
      for (let i = targets.length - 1; i >= 0; i--) {
        const t = targets[i];
        t.x += t.vx * dt; t.y += t.vy * dt;
        if (t.x < -200 || t.y < -200 || t.x > w+200 || t.y > h+200) { targets.splice(i,1); continue; }
        for (let j = missiles.length - 1; j >= 0; j--) {
          const m = missiles[j];
          const dx = t.x - m.x, dy = t.y - m.y;
          if (dx*dx + dy*dy < (t.r+2)*(t.r+2)) { targets.splice(i,1); missiles.splice(j,1); score += 10; break; }
        }
      }

      // Spawn
      spawnTimer += dt;
      if (spawnTimer > 1.0) { spawnTimer = 0; if (targets.length < 6) spawnTarget(); }

      scoreEl.textContent = 'Score: ' + score;
    }

    function fireMissile(){
      const speed = 500;
      const nx = Math.cos(jet.angle), ny = Math.sin(jet.angle);
      missiles.push({ x: jet.x + nx*(jet.radius+6), y: jet.y + ny*(jet.radius+6), vx: jet.vx + nx*speed, vy: jet.vy + ny*speed, life: 3.0 });
    }

    // Rendering
    function draw(){
      if (!jet) return;
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      ctx.fillStyle = '#061428'; ctx.fillRect(0,0,w,h);
      drawStars();
      // targets
      for (const t of targets){ ctx.beginPath(); ctx.fillStyle = '#ff8f8f'; ctx.arc(t.x,t.y,t.r,0,TAU); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.stroke(); }
      // missiles
      for (const m of missiles){ ctx.save(); ctx.translate(m.x,m.y); ctx.fillStyle='#ffd89b'; ctx.beginPath(); ctx.arc(0,0,3,0,TAU); ctx.fill(); ctx.restore(); }
      // jet
      ctx.save(); ctx.translate(jet.x,jet.y); ctx.rotate(jet.angle);
      ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-12,10); ctx.lineTo(-8,0); ctx.lineTo(-12,-10); ctx.closePath(); ctx.fillStyle='#9be7ff'; ctx.fill();
      ctx.beginPath(); ctx.fillStyle='#063c4d'; ctx.ellipse(6,0,5,6,0,0,TAU); ctx.fill();
      ctx.fillStyle='rgba(255,160,40,0.75)'; ctx.beginPath(); ctx.moveTo(-12,0); ctx.lineTo(-22,6); ctx.lineTo(-22,-6); ctx.fill();
      ctx.restore();
      // crosshair
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.moveTo(w/2-10,h/2); ctx.lineTo(w/2+10,h/2); ctx.moveTo(w/2,h/2-10); ctx.lineTo(w/2,h/2+10); ctx.stroke();

      // optional: render touch joystick debug (disabled to avoid clutter)
    }

    // Background stars
    const starSeed = [];
    for (let i=0;i<120;i++) starSeed.push({ x: Math.random()*2000-500, y: Math.random()*2000-500, s: Math.random()*1.6, a: Math.random()*0.6+0.2 });
    function drawStars(){
      const w = canvas.width / (window.devicePixelRatio || 1), h = canvas.height / (window.devicePixelRatio || 1);
      const camX = jet ? jet.x - w/2 : 0, camY = jet ? jet.y - h/2 : 0;
      for (const s of starSeed){
        const x = posMod(s.x - camX*0.2, w + 100) + (w*0.05);
        const y = posMod(s.y - camY*0.2, h + 100) + (h*0.05);
        ctx.fillStyle = 'rgba(255,255,255,' + s.a + ')';
        ctx.fillRect(x,y,s.s,s.s);
      }
    }

    // Main loop
    function loop(ts){
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Start
    initGame();
    lastTime = performance.now();
    requestAnimationFrame(loop);

    // Make touch UI visible & positioned properly
    function initTouchUIPlacement(){
      // position left joystick at bottom-left and fire button at bottom-right using CSS
      const sz = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ui-size')) || 110;
      joyBase.style.bottom = '18px';
      joyBase.style.left = '18px';
      joyBase.style.width = sz + 'px';
      joyBase.style.height = sz + 'px';
      joyKnob.style.width = (sz*0.48) + 'px';
      joyKnob.style.height = (sz*0.48) + 'px';
      fireBtn.style.bottom = '18px';
      fireBtn.style.right = '18px';
      fireBtn.style.width = sz + 'px';
      fireBtn.style.height = sz + 'px';
    }
    initTouchUIPlacement();

    // Accessibility: allow clicking the fire button with keyboard (Enter)
    fireBtn.tabIndex = 0;
    fireBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { touchState.fire = true; }});
    fireBtn.addEventListener('keyup', (e) => { if (e.key === 'Enter' || e.key === ' ') { touchState.fire = false; }});

    // Prevent the context menu on long press (mobile)
    window.addEventListener('contextmenu', e => { if (e.target === joyBase || e.target === fireBtn) e.preventDefault(); });

  })();
  </script>
</body>
</html>
