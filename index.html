<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Jet Game — DEBUG</title>
  <style>
    :root { --bg:#0b1220; --panel:rgba(255,255,255,0.06); --accent:#1fb6ff; --ui-size:110px; --bomb-size:86px; }
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#031225,#061428);color:#dfefff;user-select:none;touch-action:none;}
    #hud{position:absolute;z-index:40;left:12px;top:12px;padding:10px;background:var(--panel);border-radius:8px;max-width:420px}
    canvas{display:block;width:100vw;height:100vh;background:transparent; z-index:0}
    /* touch UI kept minimal for debug */
    #joyBase { position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:50%; background:rgba(255,255,255,0.03); z-index:45 }
    #joyKnob { width:48px; height:48px; background:rgba(31,182,255,0.95); border-radius:50%; margin:31px; }
    #fireBtn { position:fixed; right:18px; bottom:18px; width:110px; height:110px; border-radius:50%; background:#ff8f6b; z-index:45; display:flex; align-items:center; justify-content:center }
    #debugPanel { position: fixed; right: 12px; top: 12px; background: rgba(0,0,0,0.5); color: #fff; padding:8px; border-radius:6px; z-index:50; font-family:monospace; font-size:13px; }
  </style>
</head>
<body>
  <div id="hud">
    <div style="font-weight:700; color:var(--accent)">Jet Game — DEBUG</div>
    <div>Max Speed: <input id="speedSlider" type="range" min="50" max="600" value="300" /></div>
    <div><button id="restartBtn">Restart</button> <button id="logBtn">Log State</button></div>
    <div style="margin-top:6px; font-size:13px; opacity:0.9">Controls: Arrow keys / W S / Space; touch joystick / FIRE; gamepad supported</div>
  </div>

  <div id="debugPanel">debug: initializing...</div>

  <canvas id="game"></canvas>

  <!-- tiny touch UI -->
  <div id="joyBase"><div id="joyKnob"></div></div>
  <div id="fireBtn">FIRE</div>

  <script>
  // DEBUG build: draws an obvious red dot for the jet and a debug HUD.
  (function () {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(320, window.innerWidth);
      const h = Math.max(240, window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener('resize', resize);
    resize();

    // UI refs
    const speedSlider = document.getElementById('speedSlider');
    const restartBtn = document.getElementById('restartBtn');
    const debugPanel = document.getElementById('debugPanel');
    const logBtn = document.getElementById('logBtn');

    let maxSpeed = Number(speedSlider.value);
    speedSlider.addEventListener('input', (e) => { maxSpeed = Number(e.target.value); });

    restartBtn.addEventListener('click', initGame);
    logBtn.addEventListener('click', () => console.log('STATE', { jet }));

    // input
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // simple touch joystick handlers (not full-featured; just set joystick state)
    const joyBase = document.getElementById('joyBase'), joyKnob = document.getElementById('joyKnob');
    const fireBtn = document.getElementById('fireBtn');
    const touchState = { joystick: { active: false, id: null, x: 0, y: 0 }, fire: false };

    function getBaseParams(el) { const r = el.getBoundingClientRect(); return { cx: r.left + r.width/2, cy: r.top + r.height/2, r: Math.min(r.width, r.height)/2 }; }

    joyBase.addEventListener('pointerdown', ev => { joyBase.setPointerCapture(ev.pointerId); touchState.joystick.active = true; touchState.joystick.id = ev.pointerId; updateJoy(ev.clientX, ev.clientY); });
    joyBase.addEventListener('pointermove', ev => { if (!touchState.joystick.active || touchState.joystick.id !== ev.pointerId) return; updateJoy(ev.clientX, ev.clientY); });
    joyBase.addEventListener('pointerup', (ev) => { if (touchState.joystick.id !== ev.pointerId) return; touchState.joystick.active = false; touchState.joystick.id = null; touchState.joystick.x = 0; touchState.joystick.y = 0; joyKnob.style.transform = 'translate(0,0)'; });
    function updateJoy(px, py) { const p = getBaseParams(joyBase); const nx = (px - p.cx) / p.r; const ny = (py - p.cy) / p.r; touchState.joystick.x = Math.max(-1, Math.min(1, nx)); touchState.joystick.y = Math.max(-1, Math.min(1, ny)); const mvx = touchState.joystick.x * p.r * 0.4; const mvy = touchState.joystick.y * p.r * 0.4; joyKnob.style.transform = `translate(${mvx}px, ${mvy}px)`; }

    fireBtn.addEventListener('pointerdown', ev => { fireBtn.setPointerCapture(ev.pointerId); touchState.fire = true; });
    fireBtn.addEventListener('pointerup', ev => { touchState.fire = false; try { fireBtn.releasePointerCapture(ev.pointerId); } catch (e) {} });

    // game state
    let jet = null, missiles = [], targets = [], lastTime = performance.now(), score = 0, spawnTimer = 0;
    function initGame() {
      const dpr = window.devicePixelRatio || 1;
      jet = { x: canvas.width / (2 * dpr), y: canvas.height / (2 * dpr), angle: -Math.PI / 2, vx: 0, vy: 0, radius: 18, cooldown: 0 };
      missiles = []; targets = []; lastTime = performance.now(); score = 0; spawnTimer = 0;
      console.log('initGame: center', jet.x, jet.y);
    }
    initGame();

    function spawnTarget() { const w = canvas.width / (window.devicePixelRatio || 1), h = canvas.height / (window.devicePixelRatio || 1); const edge = Math.floor(Math.random()*4); let x,y; if (edge===0){ x=-60; y=Math.random()*h } else if (edge===1){ x=w+60; y=Math.random()*h } else if (edge===2){ x=Math.random()*w; y=-60 } else { x=Math.random()*w; y=h+60 } const angle = Math.atan2(h/2 - y, w/2 - x); const speed = 60 + Math.random()*100; targets.push({ x,y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, r: 12 }); }

    function fireMissile() { const speed = 420; const nx = Math.cos(jet.angle), ny = Math.sin(jet.angle); const m = { x: jet.x + nx*(jet.radius+6), y: jet.y + ny*(jet.radius+6), vx: jet.vx + nx*speed, vy: jet.vy + ny*speed, life: 4.0 }; missiles.push(m); console.log('FIRE missile', m); }

    function update(dt) {
      if (!jet) return;
      // input
      let throttle = 0, turn = 0, fire = false;
      if (keys['ArrowLeft'] || keys['KeyA']) turn -= 1;
      if (keys['ArrowRight'] || keys['KeyD']) turn += 1;
      if (keys['KeyW']) throttle += 1;
      if (keys['KeyS']) throttle -= 1;
      if (keys['Space']) fire = true;

      // touch joystick
      if (touchState.joystick.active) { turn = touchState.joystick.x; throttle = -touchState.joystick.y; }
      if (touchState.fire) fire = true;

      // physics
      const targetSpeed = throttle * maxSpeed;
      const fx = Math.cos(jet.angle), fy = Math.sin(jet.angle);
      const currentAlong = jet.vx*fx + jet.vy*fy;
      const accel = Math.max(-800, Math.min(800, (targetSpeed - currentAlong) * 4));
      jet.vx += fx * accel * dt;
      jet.vy += fy * accel * dt;
      jet.angle += turn * 3.5 * dt;
      jet.vx *= 0.994; jet.vy *= 0.994;
      const spd = Math.hypot(jet.vx, jet.vy);
      if (spd > maxSpeed * 1.5) { const s = (maxSpeed*1.5)/spd; jet.vx *= s; jet.vy *= s; }

      // move
      jet.x += jet.vx * dt; jet.y += jet.vy * dt;

      // clamp to screen (jet must NOT leave)
      const w = canvas.width / (window.devicePixelRatio || 1), h = canvas.height / (window.devicePixelRatio || 1);
      const minX = jet.radius, maxX = Math.max(jet.radius, w - jet.radius);
      const minY = jet.radius, maxY = Math.max(jet.radius, h - jet.radius);
      if (jet.x < minX){ jet.x = minX; if (jet.vx < 0) jet.vx = 0; }
      if (jet.x > maxX){ jet.x = maxX; if (jet.vx > 0) jet.vx = 0; }
      if (jet.y < minY){ jet.y = minY; if (jet.vy < 0) jet.vy = 0; }
      if (jet.y > maxY){ jet.y = maxY; if (jet.vy > 0) jet.vy = 0; }

      // firing
      jet.cooldown -= dt;
      if (fire && jet.cooldown <= 0) { fireMissile(); jet.cooldown = 0.25; }

      // missiles
      for (let i = missiles.length-1; i>=0; i--){
        const m = missiles[i];
        m.x += m.vx * dt; m.y += m.vy * dt; m.life -= dt;
        // bounce
        if (m.x < 0){ m.x = 0; m.vx = -m.vx * 0.9; }
        if (m.x > w){ m.x = w; m.vx = -m.vx * 0.9; }
        if (m.y < 0){ m.y = 0; m.vy = -m.vy * 0.9; }
        if (m.y > h){ m.y = h; m.vy = -m.vy * 0.9; }
        if (m.life <= 0) missiles.splice(i,1);
      }

      // targets
      for (let i = targets.length-1; i>=0; i--){
        const t = targets[i];
        t.x += t.vx * dt; t.y += t.vy * dt;
        if (t.x < -200 || t.y < -200 || t.x > w+200 || t.y > h+200) { targets.splice(i,1); continue; }
        // collisions with missiles
        for (let j = missiles.length-1; j>=0; j--){
          const m = missiles[j];
          const dx = t.x - m.x, dy = t.y - m.y;
          if (dx*dx + dy*dy < (t.r+4)*(t.r+4)) { targets.splice(i,1); missiles.splice(j,1); score += 10; break; }
        }
      }

      // spawn
      spawnTimer += dt;
      if (spawnTimer > 1.0) { spawnTimer = 0; if (targets.length < 6) spawnTarget(); }

      // update debug panel
      debugPanel.textContent = `jet: x=${Math.round(jet.x)}, y=${Math.round(jet.y)} vx=${jet.vx.toFixed(1)} vy=${jet.vy.toFixed(1)} angle=${jet.angle.toFixed(2)} score=${score} missiles=${missiles.length} targets=${targets.length}`;
    }

    function draw() {
      const w = canvas.width / (window.devicePixelRatio || 1), h = canvas.height / (window.devicePixelRatio || 1);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h); // black background for strong contrast
      // draw star field (simple)
      ctx.fillStyle = '#111';
      for (let i=0;i<60;i++) ctx.fillRect((i*37)%w, (i*53)%h, 1, 1);

      // draw targets
      for (const t of targets) {
        ctx.beginPath(); ctx.fillStyle = '#ff8f8f'; ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
      }

      // draw missiles
      for (const m of missiles) {
        ctx.save(); ctx.translate(m.x, m.y); ctx.fillStyle = '#ffd89b'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill(); ctx.restore();
      }

      // draw a very visible jet marker (red circle + white outline)
      if (jet) {
        ctx.save();
        ctx.translate(jet.x, jet.y);
        ctx.rotate(jet.angle);
        // visible big dot
        ctx.beginPath();
        ctx.fillStyle = '#ff2d2d';
        ctx.arc(0, 0, 12, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
        // small nose indicator
        ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(14,0,4,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // center crosshair
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.beginPath(); ctx.moveTo(w/2 - 10, h/2); ctx.lineTo(w/2 + 10, h/2); ctx.moveTo(w/2, h/2 - 10); ctx.lineTo(w/2, h/2 + 10); ctx.stroke();
    }

    // animation loop
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    lastTime = performance.now();
    requestAnimationFrame(loop);

    // initial console log
    console.log('DEBUG build loaded — no errors printed below means rendering ran. If you do not see the red jet marker, paste console output here.');

  })();
  </script>
</body>
</html>
